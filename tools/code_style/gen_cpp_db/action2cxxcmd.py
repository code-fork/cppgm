# This is the implementation of a Bazel extra_action which genenerates
# _compile_command files for generate_compile_commands.py to consume.

import argparse
import json
import subprocess
import sys

# The module below is generated by running protoc on the file below:
#       https://github.com/bazelbuild/bazel/blob/master/src/main/protobuf/extra_actions_base.proto
# For easy reference, a copy of the file is stored in this same directory.
import extra_actions_base_pb2


def update_parser(parser):
    parser.add_argument(
        'extra_action_bin',
        help='the file name of the serialized extra_action message')
    parser.add_argument(
        'output_file',
        help='output file name')


def main():
    parser = argparse.ArgumentParser(description=__doc__)
    update_parser(parser)

    args = parser.parse_args()

    action = extra_actions_base_pb2.ExtraActionInfo()
    with open(args.extra_action_bin, 'rb') as f:
        action.MergeFromString(f.read())
    cpp_compile_info = action.Extensions[
            extra_actions_base_pb2.CppCompileInfo.cpp_compile_info]
    cmd = [ cpp_compile_info.tool,
        '-c', cpp_compile_info.source_file,
        '-o', cpp_compile_info.output_file,
    ] + [str(x) for x in cpp_compile_info.compiler_option]
    cmdstr = subprocess.list2cmdline(cmd)
    source_fname = cpp_compile_info.source_file

    data = { 'command': cmdstr, 'file': source_fname }
    # Blacklisted files result in empty json objects.
    # TODO: Formalize the blacklisting of files.
    if source_fname.startswith('third_party/'):
        data = {}
    with open(args.output_file, 'w') as f:
        json.dump(data, f, sort_keys=True, indent=4)


if __name__ == '__main__':
    main()
